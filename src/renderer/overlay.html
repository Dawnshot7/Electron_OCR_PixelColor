<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Overlay</title>
  <style>
    body {
      background: rgba(0, 0, 0, 0); /* Adjust transparency as needed */
    }
    .test-box {
      border: 2px solid white;
      padding: 20px;
      background-color: rgba(255, 255, 255, 0);
    }
    .alert {
      position: absolute;
      padding: 20px;
      background-color: rgba(255, 255, 255, 0.0);
      display: 'none';
    }
    /* Style for draggable alerts */
    .draggable {
      cursor: move;
    }
  </style>
</head>
<body>
  <button id="hideDraggableOverlay">Hide Edit Mode Overlay</button> <!-- Button to toggle edit mode -->
  <div id="alerts-container"></div> <!-- Container for dynamic alerts -->

  <script>
    // Track edit mode state
    let isEditMode = false;

    // Initialize all alerts on load
    window.electronAPI.onInitAlerts((alerts) => {
      console.log('received initAlerts in overlay');
      isEditMode = false;
      renderAlerts(alerts);
    });

    // Re-initialize all alerts as visible and draggable in edit mode
    window.electronAPI.onDragAlerts((alerts) => {
      console.log(`received updateAlerts in overlay`, alerts);
      isEditMode = true;
      renderAlerts(alerts);
    });

    // Show/hide alerts based on continuous IPC data in game mode
    window.electronAPI.onUpdateVisibleAlerts((visibleAlertIds) => {
      const alertDivs = document.querySelectorAll('.alert');
      alertDivs.forEach(alertDiv => {
        if (visibleAlertIds.includes(alertDiv.id)) {
          alertDiv.style.display = 'block'; // Show alert
        } else {
          alertDiv.style.display = 'none'; // Hide alert
        }
      });
    });

    // Function to render alerts based on config
    function renderAlerts(alertConfig) {
      const alertsContainer = document.getElementById('alerts-container');
      alertsContainer.innerHTML = ''; // Clear existing alerts

      for (const [key, alert] of Object.entries(alertConfig)) {
        if (alert && typeof alert === 'object' && 'x' in alert && 'y' in alert && key !== 'alertsDefault') {
          const alertDiv = document.createElement('div');
          alertDiv.classList.add('alert');
          alertDiv.id = key; // Set ID for drag handling
          alertDiv.style.left = `${alert.x}px`;
          alertDiv.style.top = `${alert.y}px`;

          if (alert.type === 'image') {
            const img = document.createElement('img');
            img.src = alert.src;
            img.style.width = '100%';
            img.style.height = '100%';
            alertDiv.appendChild(img);
          } else if (alert.type === 'text') {
            alertDiv.innerText = alert.content || '';
            alertDiv.style.color = alert.color || 'white';
            alertDiv.style.fontSize = (alert.textSize || '20') + 'px';
          }

          // Add drag capabilities if in edit mode
          if (isEditMode) {
            alertDiv.classList.add('draggable');
            alertDiv.setAttribute('draggable', 'true');
            alertDiv.addEventListener('dragstart', handleDragStart);
            alertDiv.addEventListener('drag', handleDrag);
            alertDiv.addEventListener('dragend', handleDragEnd);
            alertDiv.style.display = 'block';            
          }

          alertsContainer.appendChild(alertDiv);
        }
      }
    }

    // Function to toggle edit mode
    document.getElementById('hideDraggableOverlay').addEventListener('click', hideDraggableOverlay);

    function hideDraggableOverlay() {
      isEditMode = false;
      const alertDivs = document.querySelectorAll('.alert');

      // Notify main process to enable or disable click-through
      window.electronAPI.hideDraggableOverlay();

      alertDivs.forEach(alertDiv => {
        alertDiv.classList.remove('draggable');
        alertDiv.removeAttribute('draggable');
        alertDiv.removeEventListener('dragstart', handleDragStart);
        alertDiv.removeEventListener('drag', handleDrag);
        alertDiv.removeEventListener('dragend', handleDragEnd);
        alertDiv.style.display = 'none';  
      });
    }

    let offsetX, offsetY;

    // Start drag handler
    function handleDragStart(event) {
      offsetX = event.clientX - event.target.offsetLeft;
      offsetY = event.clientY - event.target.offsetTop;
      event.dataTransfer.setData('text/plain', event.target.id);
    }

    // Track drag movement to update position
    function handleDrag(event) {
      if (event.clientX > 0 && event.clientY > 0) { // Ensure valid drag position
        event.target.style.left = `${event.clientX - offsetX}px`;
        event.target.style.top = `${event.clientY - offsetY}px`;
      }
    }

    // End drag handler to capture new position
    function handleDragEnd(event) {
      const newX = parseInt(event.target.style.left, 10);
      const newY = parseInt(event.target.style.top, 10);
      const id = event.target.id;

      // Send the new position back to main.js
      window.electronAPI.updateVariable('alerts',id, { x: newX, y: newY });
    }
  </script>
</body>
</html>
